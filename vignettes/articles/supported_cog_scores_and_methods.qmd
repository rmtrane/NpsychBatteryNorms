---
title: "Supported Cognitive Scores and Methods"
format: 
  html:
    embed-resources: false
execute:
  echo: false
---

```{r}
#| label: data-prep
#| echo: false
#| warning: false
#| message: false

library(NpsychBatteryNorms)
library(dplyr)
library(tidyr)
library(purrr) 
library(stringr)
library(reactable)

for_tab <- tibble(
  method = c("norms", "regression", "T-score"),
  tab = map(
    method,
    \(mth) {
      version <- switch(
        mth,
        "norms" = names(NpsychBatteryNorms::normative_summaries),
        "regression" = names(NpsychBatteryNorms::reg_coefs),
        NA
      )
      variables <- map(
        version,
        \(y) NpsychBatteryNorms::std_methods(method = mth, version = y)
      )

      version <- factor(
        if_else(is.na(version), "T", version),
        levels = c(na.omit(unique(version)), "T")
      )

      tibble(
        variables,
        version
      ) |> 
        unnest_longer(variables)
    }
  )
) |> 
  unnest(tab) |> 
  mutate(
    version = str_replace_all(
      version, 
      c(
        "nacc" = "NACC",
        "_legacy" = "(Legacy)",
        "updated_2024.06" = "Updated (June 2024)",
        "updated_2025.06" = "Updated (June 2025)",
        "updated" = "Updated",
        "T" = ""
      )
    ),
    method = str_replace_all(
      method,
      c(
        "norms" = "Normative Look-Up Table",
        "regression" = "Regression Model"
      )
    ),
    short_descriptor = map_chr(variables, \(x) {
      sd <- rdd[[x]]$short_descriptor

      if (is.null(sd)) return(NA)

      sd
    })
  ) |> 
  select(
    variables,
    short_descriptor,
    method, 
    version
  ) |> 
  arrange(variables)
```


```{r}
filter_input <- JS("
  function(column, state) {
    // Debug: log the current state
    console.log('Column ID:', column.id)
    console.log('Current filters:', state.filtered)
    
    const uniqueValues = [...new Set(state.data.map(row => row[column.id]))].sort()
    
    // Find and log current value
    let currentValue = ''
    if (state.filtered && state.filtered.length > 0) {
      const currentFilter = state.filtered.find(f => f.id === column.id)
      if (currentFilter) {
        currentValue = currentFilter.value || ''
      }
    }
    
    const options = [
      React.createElement('option', { value: '', key: 'all' }, 'All'),
      ...uniqueValues.map(val => 
        React.createElement('option', { value: val, key: val }, val)
      )
    ]
    
    // Log what value we're setting
    console.log('Setting select value to:', currentValue)
    
    return React.createElement('select', {
      defaultValue: '',
      onChange: function(e) {
        console.log('Changed to:', e.target.value)
        column.setFilter(e.target.value || undefined)
      },
      'aria-label': `Filter ${column.id}`,
      style: { width: '100%', height: '28px' }
    }, options)
  }
")
```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: asis
#| include: true
#| column: page
for_tab |>
  # summarize(.by = -version, version = paste(version, collapse = "<br>")) |> 
  # pivot_wider(names_from = method, values_from = version) |> 
  reactable::reactable(
    elementId = "vars-and-meths",
    sortable = F,
    defaultPageSize = 10,
    showPageSizeOptions = T,
    pageSizeOptions = c(5, 10, 25, 50, 100, 200),
    theme = reactable::reactableTheme(
      backgroundColor = "var(--bs-body-bg)",
      selectStyle = list(
        "background-color" = "var(--bs-body-bg)",
        "border-color" = "var(--bs-font-color)"
      )
    ),
    # columnGroups = list(
    #     reactable::colGroup(
    #     name = "Cognitive Score Descriptors",
    #     columns = c("variables", "short_descriptor")
    #   )
    # ),
    columns = list(
      variables = reactable::colDef(
        name = "NACC Name",
        html = TRUE,
        filterable = TRUE,
        filterInput = filter_input,
        filterMethod = reactable::JS("function(rows, columnId, filterValue) {
          return rows.filter(function(row) {
            return String(row.values[columnId]) === filterValue
          })
        }"),
        style = reactable::JS("function(rowInfo, column, state) {
          if (rowInfo?.viewIndex === undefined) {
            return
          }

          const prevRow = state.pageRows[rowInfo.viewIndex - 1]
          if (prevRow && rowInfo.values[column.id] === prevRow[column.id]) {
            return { visibility: 'hidden', 'white-space': 'nowrap'}
          } else {
            return { 'white-space': 'nowrap'}
          }
        }")
      ),
      short_descriptor = reactable::colDef(
        name = "NACC Short Description",
        filterable = TRUE,
        filterInput = filter_input,
        html = TRUE,
        style = reactable::JS("function(rowInfo, column, state) {
          if (rowInfo?.viewIndex === undefined) {
            return
          }
          const prevRow = state.pageRows[rowInfo.viewIndex - 1]
          if (prevRow && rowInfo.values[column.id] === prevRow[column.id]) {
            return { visibility: 'hidden'}
          } 
        }")
      ),
      method = reactable::colDef(
        name = "Method",
        filterable = TRUE,
        filterInput = filter_input,
        style = reactable::JS("function(rowInfo, column, state) {
          if (rowInfo?.viewIndex === undefined) {
            return
          }

          const prevRow = state.pageRows[rowInfo.viewIndex - 1]
          if (
            prevRow && 
            rowInfo.values[column.id] === prevRow[column.id] && 
            rowInfo.values['variables'] === prevRow['variables']
          ) {
            return { visibility: 'hidden'}
          }
        }")
      ),
      version = reactable::colDef(
        name = "Versions",
        html = TRUE,
        style = reactable::JS("function(rowInfo, column, state) {
          if (rowInfo?.viewIndex === undefined) {
            return
          }
          const prevRow = state.pageRows[rowInfo.viewIndex - 1]

          if (
            prevRow && 
            rowInfo.values['variables'] === prevRow['variables'] && 
            rowInfo.values['method'] === prevRow['method']
          ) {
            return { 'border-top': 'none'}
          } 
        }")
      )
    ),
    rowStyle = reactable::JS("
      function(rowInfo, state) {
        
        if (rowInfo?.viewIndex === undefined) {
          return
        }

        const prevRow = state.pageRows[rowInfo.viewIndex - 1]

        if (
          rowInfo.viewIndex === 0 || 
          rowInfo.values['variables'] !== prevRow['variables']
        ) {
          return { 'border-color': '#A3A3A3', 'border-top-style': 'solid'}
        }
      }
    ")
  )
```